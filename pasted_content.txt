# -*- coding: utf-8 -*-
import os
import pandas as pd
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import matplotlib.dates as mdates
import seaborn as sns
import numpy as np
from datetime import datetime, time
from flask import Flask, request, render_template, send_file, after_this_request
import shutil
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Image, Paragraph, Spacer, Table, TableStyle
from reportlab.lib import colors
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
import traceback

app = Flask(__name__)
basedir = os.path.dirname(os.path.abspath(__file__))
RELATORIOS_DIR_ABS = os.path.join(basedir, 'relatorios')

# --- Funções Auxiliares ---
def minutos_para_horario(minutos):
    if pd.isna(minutos) or minutos is None: return "N/A"
    try: minutos = int(minutos); horas = minutos // 60; mins = minutos % 60; return f"{horas:02d}:{mins:02d}"
    except (ValueError, TypeError): return "Inválido"

# --- Processamento de Dados ---
def processar_dados_excel(file, pasta_dados):
    target_result_col_name = 'Resultado_Valor'; output = os.path.join(pasta_dados, "temp_upload.xlsx"); banco_geral = None; col_to_rename = None
    try: file.save(output); banco_geral = pd.read_excel(output, engine='openpyxl')
    except Exception as e: print(f"Erro ao salvar ou ler arquivo Excel: {e}"); raise
    finally:
        if os.path.exists(output):
            try: os.remove(output); print(f"Arquivo temporário Excel removido: {output}")
            except OSError as e_remove: print(f"AVISO: Não foi possível remover o arquivo temporário {output}: {e_remove}")
    if banco_geral is None or banco_geral.empty: print("AVISO: Arquivo Excel vazio ou erro na leitura."); return pd.DataFrame(), None
    print(f"\n--- Processando Excel ---"); print(f"Shape inicial Excel: {banco_geral.shape}"); print(f"Colunas Excel: {list(banco_geral.columns)}")
    if 'Abertura' in banco_geral.columns: banco_geral['Abertura_Original'] = banco_geral['Abertura'].astype(str)
    else: banco_geral['Abertura_Original'] = "Coluna Abertura Ausente"
    if 'Fechamento' in banco_geral.columns: banco_geral['Fechamento_Original'] = banco_geral['Fechamento'].astype(str)
    else: banco_geral['Fechamento_Original'] = "Coluna Fechamento Ausente"
    found_excel_res = False; primary_result_col = 'Res. Operação (%)'; fallback_result_cols = ['Res. Operação', 'Resultado', 'Profit']
    if primary_result_col in banco_geral.columns: col_to_rename = primary_result_col; found_excel_res = True
    else:
        for col in fallback_result_cols:
            if col in banco_geral.columns: col_to_rename = col; found_excel_res = True; print(f"Usando coluna fallback '{col_to_rename}' como resultado."); break
    if found_excel_res:
        print(f"Coluna Excel '{col_to_rename}' encontrada para resultado."); original_nan_count = banco_geral[col_to_rename].isna().sum()
        if original_nan_count > 0: print(f"Removendo {original_nan_count} linhas com valor de resultado original vazio/NaN."); banco_geral = banco_geral.dropna(subset=[col_to_rename]); print(f"Shape após remover NaNs de resultado: {banco_geral.shape}")
        if banco_geral.empty: print("AVISO: Nenhuma linha com valor de resultado válido encontrada no Excel."); return pd.DataFrame(), None
        banco_geral['Resultado_Original_Debug'] = banco_geral[col_to_rename].astype(str); banco_geral = banco_geral.rename(columns={col_to_rename: target_result_col_name}); print(f"Coluna '{col_to_rename}' renomeada para '{target_result_col_name}'.")
        print(f"Convertendo '{target_result_col_name}' do Excel para numérico..."); banco_geral[target_result_col_name + '_Numeric'] = pd.to_numeric(banco_geral[target_result_col_name], errors='coerce')
        nan_conversion_count = banco_geral[target_result_col_name + '_Numeric'].isna().sum()
        if nan_conversion_count > 0: print(f"AVISO EXCEL: {nan_conversion_count} valores ainda falharam na conversão numérica. Convertidos para 0."); failed_values = banco_geral.loc[banco_geral[target_result_col_name+'_Numeric'].isna(), 'Resultado_Original_Debug'].unique(); print(f"    Exemplos que falharam: {failed_values[:10]}")
        banco_geral[target_result_col_name] = banco_geral[target_result_col_name + '_Numeric'].fillna(0).astype(float); banco_geral = banco_geral.drop(columns=[target_result_col_name + '_Numeric'], errors='ignore'); print(f"Soma '{target_result_col_name}' APÓS limpeza no Excel: {banco_geral[target_result_col_name].sum():.2f}")
    else: print(f"ERRO FATAL: Nenhuma coluna de resultado utilizável encontrada no Excel. Retornando DataFrame vazio."); return pd.DataFrame(), None
    banco_geral = banco_geral.drop(columns=['Resultado_Original_Debug'], errors='ignore'); print(f"--- Fim Processamento Excel ---");
    return banco_geral, col_to_rename

def processar_dados_csv(files, pasta_dados):
    dfs = []; target_result_col_name = 'Resultado_Valor'; original_result_col_name_csv = None
    for file in files:
        if not file or not file.filename: continue
        if not file.filename.lower().endswith('.csv'): print(f"ERRO: Arquivo não CSV: {file.filename}. Pulando."); continue
        print(f"\n--- Processando CSV: {file.filename} ---"); temp_path = os.path.join(pasta_dados, file.filename);
        df = None; file_saved = False
        try: file.save(temp_path); file_saved = True; df = pd.read_csv(temp_path, skiprows=5, encoding='latin-1', sep=';')
        except Exception as e: print(f"ERRO leitura/save CSV {file.filename}: {e}. Pulando."); continue
        finally:
            if file_saved and os.path.exists(temp_path):
                try: os.remove(temp_path)
                except OSError as e_rem: print(f"AVISO: Falha ao remover temp CSV {temp_path} no finally: {e_rem}")
        if df is None or df.empty: print(f"AVISO: CSV vazio ou erro leitura: {file.filename}. Pulando."); continue
        print(f"Shape inicial: {df.shape}")
        try:
            df.columns = df.columns.str.strip(); robo_name = os.path.splitext(file.filename)[0]; df['Robo'] = robo_name; time_mapping = {'Abertura': 'Abertura', 'Data Abertura': 'Abertura', 'Open Time': 'Abertura', 'Fechamento': 'Fechamento', 'Data Fechamento': 'Fechamento', 'Close Time': 'Fechamento'}; actual_time_mapping = {k: v for k, v in time_mapping.items() if k in df.columns}; df = df.rename(columns=actual_time_mapping); primary_result_col_csv = 'Res. Operação (%)'; fallback_result_cols_csv = ['Res. Operação', 'Resultado', 'Profit']; result_col_found_in_csv = None
            if primary_result_col_csv in df.columns: result_col_found_in_csv = primary_result_col_csv
            else: result_col_found_in_csv = next((col for col in fallback_result_cols_csv if col in df.columns), None)
            if result_col_found_in_csv:
                df = df.rename(columns={result_col_found_in_csv: target_result_col_name}); print(f"Coluna resultado CSV '{result_col_found_in_csv}' -> '{target_result_col_name}'")
                if original_result_col_name_csv is None: original_result_col_name_csv = result_col_found_in_csv
            else: print(f"ERRO FATAL: Coluna resultado não encontrada em {file.filename}. Pulando."); continue
            required_columns = ['Abertura', 'Fechamento', target_result_col_name]; missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns: print(f"ERRO FATAL: Colunas obrigatórias ausentes em {file.filename}: {missing_columns}. Pulando."); continue
            if 'Abertura' in df.columns: df['Abertura_Original'] = df['Abertura'].astype(str); df['Abertura'] = pd.to_datetime(df['Abertura'], errors='coerce', dayfirst=True); print(f"NaT 'Abertura': {df['Abertura'].isna().sum()}")
            if 'Fechamento' in df.columns: df['Fechamento_Original'] = df['Fechamento'].astype(str); df['Fechamento'] = pd.to_datetime(df['Fechamento'], errors='coerce', dayfirst=True); print(f"NaT 'Fechamento': {df['Fechamento'].isna().sum()}")
            df['data'] = df['Abertura'].dt.date; df['Minutos_Dia'] = df['Abertura'].dt.hour * 60 + df['Abertura'].dt.minute; print(f"NaN 'Minutos_Dia': {df['Minutos_Dia'].isna().sum()}")
            if target_result_col_name in df.columns:
                print(f"Limpando coluna '{target_result_col_name}' do CSV..."); df['Resultado_Original_Debug'] = df[target_result_col_name].astype(str); temp_res = df[target_result_col_name].astype(str).str.strip(); temp_res = temp_res.str.replace('.', '', regex=False); temp_res = temp_res.str.replace(',', '.', regex=False); df['Resultado_Valor_Numerico'] = pd.to_numeric(temp_res, errors='coerce'); nan_resultado_count = df['Resultado_Valor_Numerico'].isna().sum(); print(f"Número de NaN em '{target_result_col_name}' após parse numérico (antes de fillna(0)): {nan_resultado_count}")
                if nan_resultado_count > 0: print(f"Linhas com erro de parse numérico (originais): {df.loc[df['Resultado_Valor_Numerico'].isna(), 'Resultado_Original_Debug'].unique()[:10]}")
                df[target_result_col_name] = df['Resultado_Valor_Numerico'].fillna(0); print(f"Soma de '{target_result_col_name}' para {robo_name} NESTE ARQUIVO após parse: {df[target_result_col_name].sum():.2f}"); df = df.drop(columns=['Resultado_Valor_Numerico', 'Resultado_Original_Debug'], errors='ignore')
            else: print(f"ERRO CRITICO: Coluna {target_result_col_name} perdida em {file.filename}. Pulando."); continue
            colunas_finais = ['Abertura', 'Fechamento', 'Robo', 'data', 'Minutos_Dia', target_result_col_name, 'Abertura_Original', 'Fechamento_Original']; colunas_presentes_finais = [col for col in colunas_finais if col in df.columns]
            if not all(c in colunas_presentes_finais for c in ['Abertura', 'Fechamento', target_result_col_name, 'Robo']): print(f"ERRO CRÍTICO: Colunas essenciais ausentes antes de df_final para {robo_name}. Pulando."); continue
            df_final = df[colunas_presentes_finais].copy(); dfs.append(df_final); print(f"--- Fim processamento CSV: {file.filename} ---")
        except Exception as e_proc: print(f"ERRO durante processamento das colunas de {file.filename}: {e_proc}. Pulando arquivo."); print(traceback.format_exc()); continue
    if not dfs: raise ValueError("Nenhum dado CSV válido processado.")
    banco_geral = pd.concat(dfs, ignore_index=True); print(f"\n--- DataFrame Consolidado Pós Concatenação ---"); print(f"Shape total: {banco_geral.shape}")
    if target_result_col_name not in banco_geral.columns: raise ValueError(f"Erro crítico: Coluna '{target_result_col_name}' ausente no DF final.")
    print(f"Soma inicial '{target_result_col_name}': {banco_geral[target_result_col_name].sum():.2f}");
    return banco_geral, original_result_col_name_csv

# --- Geração do PDF ---
def processar_dados_e_gerar_pdf(upload_type, file_single=None, files_multiple=None, pasta_dados=None):
    target_result_col_name = 'Resultado_Valor'; original_result_col_name = None
    if pasta_dados is None: raise ValueError("Caminho absoluto para pasta_dados não fornecido.")
    if not os.path.exists(pasta_dados): os.makedirs(pasta_dados)
    if upload_type == 'single':
        if not file_single: raise ValueError("Arquivo Excel não fornecido.")
        banco_geral_bruto, original_result_col_name = processar_dados_excel(file_single, pasta_dados)
        if banco_geral_bruto.empty: raise ValueError("Arquivo Excel vazio ou inválido.")
        if 'Robo' not in banco_geral_bruto.columns: banco_geral_bruto['Robo'] = 'Excel_Data'
    else:
        if not files_multiple: raise ValueError("Arquivos CSV não fornecidos.")
        banco_geral_bruto, original_result_col_name = processar_dados_csv(files_multiple, pasta_dados)
        if banco_geral_bruto.empty: raise ValueError("Nenhum arquivo CSV continha dados válidos.")
    print(f"\n--- Calculando Somas Totais (ANTES de remover datas inválidas) ---"); print(f"Shape Bruto (após remover resultados vazios): {banco_geral_bruto.shape}")
    soma_absoluta_total = banco_geral_bruto[target_result_col_name].sum(); print(f"Soma Absoluta Total (Bruta): {soma_absoluta_total:.2f}")
    somas_absolutas_por_robo = banco_geral_bruto.groupby('Robo')[target_result_col_name].sum(); print("Somas Absolutas por Robô (Bruta):"); print(somas_absolutas_por_robo)
    count_operacoes_total_originais = len(banco_geral_bruto); print(f"Total de Operações Originais (com resultado válido): {count_operacoes_total_originais}")
    print(f"\n--- Processamento Consolidado Final (Removendo datas inválidas) ---"); banco_geral = banco_geral_bruto.copy()
    banco_geral['Abertura'] = pd.to_datetime(banco_geral['Abertura'], errors='coerce', dayfirst=True); banco_geral['Fechamento'] = pd.to_datetime(banco_geral['Fechamento'], errors='coerce', dayfirst=True)
    linhas_antes_drop_datas = len(banco_geral); banco_geral = banco_geral.dropna(subset=['Abertura', 'Fechamento']); linhas_depois_drop_datas = len(banco_geral)
    print(f"Shape DEPOIS dropna datas: {banco_geral.shape}; Soma '{target_result_col_name}': {banco_geral[target_result_col_name].sum():.2f}")
    if linhas_antes_drop_datas > linhas_depois_drop_datas: print(f"AVISO: {linhas_antes_drop_datas - linhas_depois_drop_datas} linhas removidas devido a datas de Abertura/Fechamento inválidas.")
    if banco_geral.empty: raise ValueError("Nenhum dado válido restante após limpeza final de datas.")
    midnight = time(0, 0, 0); banco_geral['Tem_Hora'] = banco_geral['Abertura'].dt.time != midnight; banco_com_hora = banco_geral[banco_geral['Tem_Hora']].copy(); count_sem_hora = len(banco_geral) - len(banco_com_hora)
    if count_sem_hora > 0: print(f"INFO: {count_sem_hora} operações sem horário específico (00:00) encontradas.")
    if not banco_com_hora.empty:
        banco_com_hora['Minutos_Dia'] = banco_com_hora['Abertura'].dt.hour * 60 + banco_com_hora['Abertura'].dt.minute; banco_filtrado_8_18 = banco_com_hora[(banco_com_hora['Minutos_Dia'] >= 8 * 60) & (banco_com_hora['Minutos_Dia'] <= 18 * 60)].copy(); banco_filtrado_8_18['Hora_Abertura'] = banco_filtrado_8_18['Abertura'].dt.hour; count_operacoes_com_hora = len(banco_com_hora); count_operacoes_8_18 = len(banco_filtrado_8_18); soma_total_filtrado_8_18 = banco_filtrado_8_18[target_result_col_name].sum()
    else: print("AVISO: Nenhuma operação com horário definido encontrada."); banco_com_hora = pd.DataFrame(columns=banco_geral.columns); banco_filtrado_8_18 = pd.DataFrame(columns=banco_geral.columns); count_operacoes_com_hora = 0; count_operacoes_8_18 = 0; soma_total_filtrado_8_18 = 0
    print(f"Soma GERAL (Todas Ops Originais Válidas): {soma_absoluta_total:.2f}"); print(f"Soma Ops com Hora (8h-18h): {soma_total_filtrado_8_18:.2f}"); print(f"Total de Operações Originais (c/ resultado): {count_operacoes_total_originais}"); print(f"Operações Válidas Após Filtro Data (usadas nos gráficos): {len(banco_geral)} (Com Hora: {count_operacoes_com_hora}, Sem Hora: {count_sem_hora})"); print(f"Operações com Hora entre 8h-18h: {count_operacoes_8_18}")
    data_mais_antiga = banco_geral['Abertura'].min(); data_mais_recente = banco_geral['Abertura'].max(); periodo_str = f"{data_mais_antiga.strftime('%d/%m/%y')} a {data_mais_recente.strftime('%d/%m/%y')}" if pd.notna(data_mais_antiga) and pd.notna(data_mais_recente) else "N/D"; periodo_completo = f"Período de {data_mais_antiga.strftime('%d/%m/%Y')} - {data_mais_recente.strftime('%d/%m/%Y')}" if pd.notna(data_mais_antiga) and pd.notna(data_mais_recente) else "Período não identificado";
    horas_inteiras = range(8 * 60, (18 + 1) * 60, 60); horas_labels = [f"{h}h" for h in range(8, 19)]
    graficos = []
    if not banco_filtrado_8_18.empty:
        ganho_por_hora = banco_filtrado_8_18.groupby(['Robo', 'Hora_Abertura'])[target_result_col_name].sum().reset_index()
        plt.figure(figsize=(12, 6)); sns.lineplot(data=ganho_por_hora, x='Hora_Abertura', y=target_result_col_name, hue='Robo'); plt.title(f'Ganhos por Hora de Abertura (Operações 8h-18h com Hora - {periodo_str})'); plt.xlabel('Hora do Dia'); plt.ylabel('Resultado (pts)'); plt.grid(True); plt.tight_layout(); caminho_grafico1 = os.path.join(pasta_dados, 'ganhos_por_hora.png'); plt.savefig(caminho_grafico1); plt.close(); graficos.append({'grafico': caminho_grafico1, 'tabela': None})
    melhores_intervalos_todos_robos_df = pd.DataFrame(); melhor_inicio_geral_hhmm = "N/A"; melhor_fim_geral_hhmm = "N/A"; max_ganho_geral_8_18 = -np.inf; melhor_inicio_geral = None; melhor_fim_geral = None; caminho_grafico2 = None
    print("\n--- Calculando Melhor Intervalo Geral (8h-18h com Hora) ---")
    if 'Minutos_Dia' in banco_filtrado_8_18.columns and not banco_filtrado_8_18['Minutos_Dia'].isna().all():
        minutos_geral_8_18 = sorted(banco_filtrado_8_18['Minutos_Dia'].dropna().unique())
        if minutos_geral_8_18:
             print(f"Total de minutos únicos (8h-18h c/ Hora): {len(minutos_geral_8_18)}")
             primeiro_intervalo_geral_valido = True
             for i, inicio in enumerate(minutos_geral_8_18):
                ganho_int = -np.inf
                for fim in minutos_geral_8_18[i:]:
                     if fim < inicio: continue
                     df_intervalo_temp = banco_filtrado_8_18[(banco_filtrado_8_18['Minutos_Dia'] >= inicio) & (banco_filtrado_8_18['Minutos_Dia'] <= fim)]
                     if not df_intervalo_temp.empty:
                         ganho_int = df_intervalo_temp[target_result_col_name].sum()
                         if pd.notna(ganho_int):
                              if primeiro_intervalo_geral_valido: max_ganho_geral_8_18 = ganho_int; melhor_inicio_geral = inicio; melhor_fim_geral = fim; primeiro_intervalo_geral_valido = False; print(f"  >>> Primeiro Intervalo Geral Válido (8-18)! Ganho: {ganho_int:.2f}. Int:[{minutos_para_horario(inicio)}-{minutos_para_horario(fim)}]")
                              elif ganho_int > max_ganho_geral_8_18: print(f"  >>> Novo Melhor Geral (8-18)! Sum={ganho_int:.2f} > Max={max_ganho_geral_8_18:.2f}. Int:[{minutos_para_horario(inicio)}-{minutos_para_horario(fim)}]"); max_ganho_geral_8_18 = ganho_int; melhor_inicio_geral = inicio; melhor_fim_geral = fim
        else: print("  Nenhum minuto válido 8h-18h encontrado para calcular intervalo geral.")
        if melhor_inicio_geral is not None: melhor_inicio_geral_hhmm = minutos_para_horario(melhor_inicio_geral); melhor_fim_geral_hhmm = minutos_para_horario(melhor_fim_geral); print(f"  Melhor Intervalo Geral (8-18) Final: [{melhor_inicio_geral_hhmm}-{melhor_fim_geral_hhmm}], Ganho: {max_ganho_geral_8_18:.2f}")
        else: print(f"  Nenhum intervalo geral (8-18) com ganho válido encontrado. Max Ganho Registrado: {max_ganho_geral_8_18:.2f}"); max_ganho_geral_8_18 = 0.0
        print("--- Fim Cálculo Melhor Intervalo Geral ---\n")
    else: print("  'Minutos_Dia' ausente ou NaN em dados 8-18h, não calculou intervalo geral."); max_ganho_geral_8_18 = 0.0
    if not banco_filtrado_8_18.empty:
        # Agregar os dados por Robo e Minutos_Dia para evitar duplicatas
        banco_filtrado_8_18_agg = banco_filtrado_8_18.groupby(['Robo', 'Minutos_Dia'])[target_result_col_name].sum().reset_index()
        # Plotar o gráfico de dispersão com os dados agregados
        fig2, ax2 = plt.subplots(figsize=(12, 6))
        scatter = sns.scatterplot(data=banco_filtrado_8_18_agg, x='Minutos_Dia', y=target_result_col_name, hue='Robo', size=target_result_col_name, sizes=(20, 200), alpha=0.6, ax=ax2, legend='auto')
        plt.xticks(horas_inteiras, horas_labels)
        plt.axhline(y=0, color='red', linestyle='--', linewidth=1)
        if melhor_inicio_geral is not None:
            plt.axvline(x=melhor_inicio_geral, color='purple', linestyle=':', linewidth=1.5, label=f'Melhor Geral ({melhor_inicio_geral_hhmm}-{melhor_fim_geral_hhmm}, 8-18h)')
        melhores_intervalos_todos_robos = [];
        for robo_iter in banco_filtrado_8_18['Robo'].unique():
            df_robo_8_18 = banco_filtrado_8_18[banco_filtrado_8_18['Robo'] == robo_iter];
            if df_robo_8_18.empty or 'Minutos_Dia' not in df_robo_8_18.columns or df_robo_8_18['Minutos_Dia'].isna().all(): continue
            minutos_robo_8_18 = sorted(df_robo_8_18['Minutos_Dia'].dropna().unique());
            if not minutos_robo_8_18: continue
            max_ganho_robo_8_18 = -np.inf; melhor_inicio_robo_8_18 = None; melhor_fim_robo_8_18 = None; primeiro_valido_robo_int = True
            for i, inicio in enumerate(minutos_robo_8_18):
                for fim in minutos_robo_8_18[i:]:
                    if fim < inicio: continue; df_intervalo_temp = df_robo_8_18[(df_robo_8_18['Minutos_Dia'] >= inicio) & (df_robo_8_18['Minutos_Dia'] <= fim)];
                    if not df_intervalo_temp.empty:
                        ganho_intervalo = df_intervalo_temp[target_result_col_name].sum()
                        if pd.notna(ganho_intervalo):
                            if primeiro_valido_robo_int: max_ganho_robo_8_18 = ganho_intervalo; melhor_inicio_robo_8_18 = inicio; melhor_fim_robo_8_18 = fim; primeiro_valido_robo_int = False;
                            elif ganho_intervalo > max_ganho_robo_8_18: max_ganho_robo_8_18 = ganho_intervalo; melhor_inicio_robo_8_18 = inicio; melhor_fim_robo_8_18 = fim
            if melhor_inicio_robo_8_18 is not None: melhores_intervalos_todos_robos.append({'Robo': robo_iter,'Inicio_Intervalo': melhor_inicio_robo_8_18,'Fim_Intervalo': melhor_fim_robo_8_18,'Ganho': max_ganho_robo_8_18})
        melhores_intervalos_todos_robos_df = pd.DataFrame(melhores_intervalos_todos_robos)
        if not melhores_intervalos_todos_robos_df.empty:
            print("Plotando linhas de melhor intervalo por robô (8-18h)..."); legend_obj = ax2.get_legend()
            if legend_obj:
                legend_handles = legend_obj.legend_handles; legend_texts = legend_obj.texts
                if len(legend_handles) == len(legend_texts):
                    label_to_color = {}
                    for h, t in zip(legend_handles, legend_texts):
                        label = t.get_text(); color = 'grey'
                        try:
                            color_info = h.get_facecolor(); color = color_info[0] if isinstance(color_info, (list, np.ndarray)) and len(color_info) > 0 else color_info
                        except AttributeError:
                            try: color = h.get_color()
                            except AttributeError: pass
                        label_to_color[label] = color
                    for index, row in melhores_intervalos_todos_robos_df.iterrows():
                        robo = row['Robo']; inicio_intervalo = row['Inicio_Intervalo']; fim_intervalo = row['Fim_Intervalo']; cor_robo = label_to_color.get(robo, 'grey')
                        plt.axvline(x=inicio_intervalo, color=cor_robo, linestyle='--', linewidth=1, alpha=0.7); plt.axvline(x=fim_intervalo, color=cor_robo, linestyle='--', linewidth=1, alpha=0.7)
        plt.title(f'Ganhos por Minuto - Todos Robôs ({periodo_str})\n(N={count_operacoes_8_18} ops 8h-18h c/ Hora; Linha roxa: Melhor Int. 8h-18h)')
        plt.xlabel('Horário do Dia'); plt.ylabel('Resultado (pts)'); plt.grid(True); plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', title="Robôs"); plt.tight_layout()
        caminho_grafico2 = os.path.join(pasta_dados, 'ganhos_por_minuto_todos_robos.png'); plt.savefig(caminho_grafico2); plt.close(fig2)
        inicio_destaque_915_1230 = 9*60+15; fim_destaque_915_1230 = 12*60+30; ganho_destaque_915_1230_todos = banco_filtrado_8_18[(banco_filtrado_8_18['Minutos_Dia'] >= inicio_destaque_915_1230) & (banco_filtrado_8_18['Minutos_Dia'] <= fim_destaque_915_1230)][target_result_col_name].sum() if not banco_filtrado_8_18.empty else 0; inicio_destaque_9_1230 = 9*60; fim_destaque_9_1230 = 12*60+30; ganho_destaque_9_1230_todos = banco_filtrado_8_18[(banco_filtrado_8_18['Minutos_Dia'] >= inicio_destaque_9_1230) & (banco_filtrado_8_18['Minutos_Dia'] <= fim_destaque_9_1230)][target_result_col_name].sum() if not banco_filtrado_8_18.empty else 0; inicio_destaque_10_1230 = 10*60; fim_destaque_10_1230 = 12*60+30; ganho_destaque_10_1230_todos = banco_filtrado_8_18[(banco_filtrado_8_18['Minutos_Dia'] >= inicio_destaque_10_1230) & (banco_filtrado_8_18['Minutos_Dia'] <= fim_destaque_10_1230)][target_result_col_name].sum() if not banco_filtrado_8_18.empty else 0
        melhor_intervalo_geral_label = "Soma Melhores Int. (8-18h)"
        tabela_todos_robos_data = [ [f'Resultados - Todos Robôs (N={count_operacoes_total_originais})', '', '', '', ''], ['Geral (Todas Ops Brutas)', f'{melhor_intervalo_geral_label}', '9:15-12:30 (c/ Hora)', '9:00-12:30 (c/ Hora)', '10:00-12:30 (c/ Hora)'], [f"{soma_absoluta_total:.2f}", "{SOMA_MELHORES_PLACEHOLDER}", f"{ganho_destaque_915_1230_todos:.2f}", f"{ganho_destaque_9_1230_todos:.2f}", f"{ganho_destaque_10_1230_todos:.2f}"] ]
        graficos.append({'grafico': caminho_grafico2, 'tabela': tabela_todos_robos_data})
    else:
        print("AVISO: banco_filtrado_8_18 vazio, gráfico de pontos não gerado.")
    if not banco_geral.empty and 'Abertura' in banco_geral.columns and not banco_geral['Abertura'].isna().all():
        df_acum_todos = banco_geral.sort_values('Abertura').copy()
        robos_unicos = sorted(df_acum_todos['Robo'].unique())
        fig_montanha, ax_montanha = plt.subplots(figsize=(15, 7))
        datas = df_acum_todos['Abertura']
        ganhos_acumulados = []
        for robo in robos_unicos:
            df_robo = df_acum_todos[df_acum_todos['Robo'] == robo].sort_values('Abertura')
            if not df_robo.empty:
                df_robo['Resultado_Acumulado'] = df_robo[target_result_col_name].cumsum()
                df_robo = df_robo.set_index('Abertura')['Resultado_Acumulado'].reindex(datas, method='ffill').fillna(0)
                ganhos_acumulados.append(df_robo.values)
            else:
                ganhos_acumulados.append(np.zeros(len(datas)))
        plt.stackplot(datas, ganhos_acumulados, labels=robos_unicos, alpha=0.6)
        plt.axhline(y=0, color='black', linestyle='-', linewidth=0.8)
        plt.title(f'Ganho Acumulado por Robô - Todos Robôs ({periodo_str})\n(N={len(banco_geral)} ops, Incluindo Ops s/ Hora)', fontsize=12)
        plt.xlabel('Data e Hora da Operação', fontsize=10)
        plt.ylabel('Ganho Acumulado (pts)', fontsize=10)
        plt.grid(True, linestyle='--', alpha=0.6)
        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d/%m/%y %Hh'))
        plt.gca().xaxis.set_major_locator(mticker.MaxNLocator(nbins=8))
        plt.xticks(rotation=30, ha='right')
        plt.legend(loc='best', fontsize='small', title="Robôs")
        plt.tight_layout()
        caminho_grafico_montanha = os.path.join(pasta_dados, 'ganho_acumulado_montanha_todos_robos.png')
        plt.savefig(caminho_grafico_montanha)
        plt.close(fig_montanha)
        graficos.append({'grafico': caminho_grafico_montanha, 'tabela': None})
        print(f"Gráfico de montanha salvo em: {caminho_grafico_montanha}")
    else:
        print("AVISO: Não foi possível gerar o gráfico de montanha (banco_geral vazio ou sem datas válidas).")
    graficos_por_robo = []
    limites_ganho = {}
    soma_melhores_ganhos_individuais_8_18 = 0.0
    for robo in sorted(banco_geral['Robo'].unique()):
        print(f"--- Gerando gráficos para Robô: {robo} ---"); df_robo_full = banco_geral_bruto[banco_geral_bruto['Robo'] == robo].copy(); df_robo_filtrado_8_18 = banco_filtrado_8_18[banco_filtrado_8_18['Robo'] == robo].copy()
        if df_robo_full.empty: continue
        caminho_grafico_scatter = None; melhor_inicio_robo_hhmm = "N/A"; melhor_fim_robo_hhmm = "N/A"; max_ganho_robo_8_18 = -np.inf; melhor_inicio_robo = None; melhor_fim_robo = None; data_min_robo = df_robo_full['Abertura'].min(); data_max_robo = df_robo_full['Abertura'].max(); periodo_robo_str = f"{data_min_robo.strftime('%d/%m/%y')} a {data_max_robo.strftime('%d/%m/%y')}" if pd.notna(data_min_robo) and pd.notna(data_max_robo) else periodo_str; count_robo_total = len(df_robo_full); count_robo_8_18 = len(df_robo_filtrado_8_18)
        print(f"    Calculando melhor intervalo 8-18h para {robo}...")
        if 'Minutos_Dia' in df_robo_filtrado_8_18.columns and not df_robo_filtrado_8_18['Minutos_Dia'].isna().all():
            minutos_robo_8_18 = sorted(df_robo_filtrado_8_18['Minutos_Dia'].dropna().unique())
            if minutos_robo_8_18:
                print(f"      Total de minutos únicos (8-18h) para {robo}: {len(minutos_robo_8_18)}")
                primeiro_intervalo_valido_robo = True
                for i, inicio in enumerate(minutos_robo_8_18):
                    for fim in minutos_robo_8_18[i:]:
                        if fim < inicio: continue
                        df_intervalo_robo_temp = df_robo_filtrado_8_18[(df_robo_filtrado_8_18['Minutos_Dia'] >= inicio) & (df_robo_filtrado_8_18['Minutos_Dia'] <= fim)]
                        if not df_intervalo_robo_temp.empty:
                             ganho_intervalo = df_intervalo_robo_temp[target_result_col_name].sum()
                             if pd.notna(ganho_intervalo):
                                 if primeiro_intervalo_valido_robo: max_ganho_robo_8_18 = ganho_intervalo; melhor_inicio_robo = inicio; melhor_fim_robo = fim; primeiro_intervalo_valido_robo = False; print(f"        >>> Primeiro Intervalo Válido (8-18) {robo}! Ganho: {ganho_intervalo:.2f}. Int:[{minutos_para_horario(inicio)}-{minutos_para_horario(fim)}]")
                                 elif ganho_intervalo > max_ganho_robo_8_18: print(f"        >>> Novo Melhor (8-18) {robo}! Sum={ganho_intervalo:.2f} > Max={max_ganho_robo_8_18:.2f}. Int:[{minutos_para_horario(inicio)}-{minutos_para_horario(fim)}]"); max_ganho_robo_8_18 = ganho_intervalo; melhor_inicio_robo = inicio; melhor_fim_robo = fim
            else: print(f"      Nenhum minuto válido 8h-18h encontrado para calcular intervalo do robô {robo}.")
        if melhor_inicio_robo is not None: melhor_inicio_robo_hhmm = minutos_para_horario(melhor_inicio_robo); melhor_fim_robo_hhmm = minutos_para_horario(melhor_fim_geral); max_ganho_robo_final = max_ganho_robo_8_18; print(f"    Melhor intervalo (8-18h) final para {robo}: [{melhor_inicio_robo_hhmm}-{melhor_fim_robo_hhmm}], Ganho: {max_ganho_robo_final:.2f}")
        else: max_ganho_robo_final = 0.0; print(f"    Nenhum intervalo válido 8h-18h com ganho encontrado para {robo}. Melhor Ganho (8-18h) será 0.00")
        soma_melhores_ganhos_individuais_8_18 += max_ganho_robo_final
        if not df_robo_filtrado_8_18.empty:
             fig_sc, ax_sc = plt.subplots(figsize=(12, 6)); sns.scatterplot(data=df_robo_filtrado_8_18, x='Minutos_Dia', y=target_result_col_name, alpha=0.7, ax=ax_sc, color='tab:blue', size=target_result_col_name, sizes=(20, 200)); plt.axvspan(9*60+15, 12*60+30, color='lightgrey', alpha=0.3, label='Intervalo 9:15-12:30'); plt.xticks(horas_inteiras, horas_labels); plt.axhline(y=0, color='red', linestyle='--', linewidth=1)
             if melhor_inicio_robo is not None: plt.axvline(x=melhor_inicio_robo, color='red', linestyle='--', linewidth=1.5, label=f'Melhor Intervalo ({melhor_inicio_robo_hhmm}-{melhor_fim_robo_hhmm}, 8-18h)')
             if melhor_fim_robo is not None: plt.axvline(x=melhor_fim_robo, color='red', linestyle='--', linewidth=1.5)
             plt.title(f'Operações por Minuto - {robo} ({periodo_robo_str})\n(N={count_robo_8_18} / {count_robo_total} ops no período 8h-18h)'); plt.xlabel('Horário do Dia'); plt.ylabel('Resultado (pts)'); plt.grid(True); plt.legend(loc='best'); plt.tight_layout(); caminho_grafico_scatter = os.path.join(pasta_dados, f'ganhos_por_minuto_robo_{robo.replace(" ", "_")}.png'); plt.savefig(caminho_grafico_scatter); plt.close(fig_sc); print(f"    Gráfico Scatter salvo.")
        else: print(f"    AVISO: Nenhum dado 8h-18h para scatter do robô {robo}.")
        ganho_total_real_robo = somas_absolutas_por_robo.get(robo, 0)
        ganho_destaque_915_1230_robo = df_robo_filtrado_8_18[(df_robo_filtrado_8_18['Minutos_Dia'] >= 9*60+15) & (df_robo_filtrado_8_18['Minutos_Dia'] <= 12*60+30)][target_result_col_name].sum() if not df_robo_filtrado_8_18.empty else 0; ganho_destaque_9_1230_robo = df_robo_filtrado_8_18[(df_robo_filtrado_8_18['Minutos_Dia'] >= 9*60) & (df_robo_filtrado_8_18['Minutos_Dia'] <= 12*60+30)][target_result_col_name].sum() if not df_robo_filtrado_8_18.empty else 0; ganho_destaque_10_1230_robo = df_robo_filtrado_8_18[(df_robo_filtrado_8_18['Minutos_Dia'] >= 10*60) & (df_robo_filtrado_8_18['Minutos_Dia'] <= 12*60+30)][target_result_col_name].sum() if not df_robo_filtrado_8_18.empty else 0
        melhor_intervalo_robo_str = f"Melhor ({melhor_inicio_robo_hhmm}-{melhor_fim_robo_hhmm}, 8-18h)" if melhor_inicio_robo is not None else "Melhor (N/A)"
        tabela_robo_data = [ [f'Resultados - {robo} (N={count_robo_total})', '', '', '', ''], ['Geral (Todas Ops Brutas)', f'{melhor_intervalo_robo_str}', '9:15-12:30 (c/ Hora)', '9:00-12:30 (c/ Hora)', '10:00-12:30 (c/ Hora)'], [f"{ganho_total_real_robo:.2f}", f"{max_ganho_robo_final:.2f}", f"{ganho_destaque_915_1230_robo:.2f}", f"{ganho_destaque_9_1230_robo:.2f}", f"{ganho_destaque_10_1230_robo:.2f}"] ]; print(f"    Tabela: Geral={ganho_total_real_robo:.2f}, Melhor(8-18)={max_ganho_robo_final:.2f}")
        caminho_grafico_linha = None; melhor_limite = 0; df_robo_linha = df_robo_full.sort_values(['Abertura'])
        if not df_robo_linha.empty and 'Abertura' in df_robo_linha.columns and not df_robo_linha['Abertura'].isna().all():
             df_robo_linha['Dia'] = df_robo_linha['Abertura'].dt.date; dias_com_operacoes = sorted(df_robo_linha['Dia'].dropna().unique()); picos_diarios = []
             if dias_com_operacoes:
                 for dia in dias_com_operacoes: df_dia = df_robo_linha[df_robo_linha['Dia'] == dia]; ganho_acum = 0; ganhos_acumulados = [0]; [ganhos_acumulados.append(ganho_acum := ganho_acum + row[target_result_col_name]) for idx, row in df_dia.iterrows()]; pico = max(ganhos_acumulados) if len(ganhos_acumulados) > 1 else 0; picos_diarios.append(pico)
                 if picos_diarios: picos_positivos = [p for p in picos_diarios if p > 0]; melhor_limite = int(np.percentile(picos_positivos, 80)) if picos_positivos else 0
                 limites_ganho[robo] = melhor_limite; print(f"    Limite ideal: {melhor_limite} pts")
                 tempos_por_dia = []; ganhos_por_dia = []; inicios_dias = []; labels_dias = []; tempo_total_plot = 0
                 for idx_dia, dia_dt in enumerate(dias_com_operacoes):
                     df_dia = df_robo_linha[df_robo_linha['Dia'] == dia_dt].sort_values('Abertura');
                     if df_dia.empty: continue
                     try: inicio_dia_base_dt = pd.to_datetime(f"{dia_dt.strftime('%Y-%m-%d')} 00:00:00")
                     except Exception: continue
                     tempos_dia_plot = [tempo_total_plot]; ganhos_dia_plot = [0]; ganho_acum_dia = 0
                     for idx, row in df_dia.iterrows():
                         if pd.isna(row['Abertura']): continue
                         minutos_desde_meia_noite = (row['Abertura'] - inicio_dia_base_dt).total_seconds() / 60; posicao_x = tempo_total_plot + minutos_desde_meia_noite; tempos_dia_plot.append(posicao_x); ganhos_dia_plot.append(ganho_acum_dia); ganho_acum_dia += row[target_result_col_name]; tempos_dia_plot.append(posicao_x); ganhos_dia_plot.append(ganho_acum_dia)
                     minutos_fim_dia_real = 24*60-1; posicao_x_fim = tempo_total_plot + minutos_fim_dia_real
                     if tempos_dia_plot[-1] < posicao_x_fim: tempos_dia_plot.append(posicao_x_fim); ganhos_dia_plot.append(ganho_acum_dia)
                     if len(tempos_dia_plot) > 1: tempos_por_dia.append(np.array(tempos_dia_plot)); ganhos_por_dia.append(np.array(ganhos_dia_plot)); inicios_dias.append(tempo_total_plot); labels_dias.append(dia_dt.strftime('%d/%m')); tempo_total_plot += (24*60)
                 if tempos_por_dia:
                     fig_li, ax_li = plt.subplots(figsize=(15, 6)); max_y = 0; min_y = 0
                     for idx_dia, (tempos_dia_plot, ganhos_dia_plot) in enumerate(zip(tempos_por_dia, ganhos_por_dia)): ax_li.plot(tempos_dia_plot, ganhos_dia_plot, label='_nolegend_' if idx_dia > 0 else f'{robo} - Saldo Diário', color='blue', linewidth=1.5); max_y = max(max_y, ganhos_dia_plot.max()) if ganhos_dia_plot.size > 0 else max_y ; min_y = min(min_y, ganhos_dia_plot.min()) if ganhos_dia_plot.size > 0 else min_y
                     tick_positions = inicios_dias; ax_li.set_xticks(tick_positions); ax_li.set_xticklabels(labels_dias, rotation=45, ha='right', fontsize=8); [ax_li.axvline(x=inicio_dia_plot, color='gray', linestyle=':', linewidth=0.7, alpha=0.6) for inicio_dia_plot in inicios_dias[1:]]
                     if melhor_limite != 0: ax_li.axhline(y=melhor_limite, color='orange', linestyle='--', linewidth=1.5, label=f'Limite Ideal ({melhor_limite} pts)')
                     ax_li.axhline(y=0, color='black', linestyle='-', linewidth=0.8); ax_li.set_title(f'Evolução Diária do Saldo - Robô {robo} ({periodo_robo_str})'); ax_li.set_xlabel('Dias'); ax_li.set_ylabel('Saldo Acumulado no Dia (pts)'); ax_li.grid(axis='y', linestyle='--', alpha=0.7); ax_li.legend(loc='best'); padding_y = (max_y - min_y) * 0.1 + 1; ax_li.set_ylim(min_y - padding_y, max_y + padding_y); ax_li.xaxis.set_major_locator(mticker.MaxNLocator(nbins=min(len(inicios_dias), 30), integer=True)); plt.tight_layout(); caminho_grafico_linha = os.path.join(pasta_dados, f'linha_ganho_{robo.replace(" ", "_")}.png'); plt.savefig(caminho_grafico_linha); plt.close(fig_li); print(f"    Gráfico de Linha salvo.")
        caminho_grafico_acum_robo = None
        print(f"    Gerando gráfico acumulado para {robo}..."); df_acum_robo = df_robo_full.sort_values('Abertura').copy()
        if not df_acum_robo.empty and 'Abertura' in df_acum_robo and not df_acum_robo['Abertura'].isna().all():
            df_acum_robo['Resultado_Acumulado'] = df_acum_robo[target_result_col_name].cumsum(); fig_acr, ax_acr = plt.subplots(figsize=(15, 7)); ax_acr.plot(df_acum_robo['Abertura'], df_acum_robo['Resultado_Acumulado'], label='Saldo Acumulado (Todas Ops Válidas)', color='black', linewidth=2, zorder=3);
            df_acum_robo_com_hora = df_acum_robo[df_acum_robo['Abertura'].dt.time != midnight].copy()
            if not df_acum_robo_com_hora.empty:
                 if 'Minutos_Dia' not in df_acum_robo_com_hora.columns: df_acum_robo_com_hora['Minutos_Dia'] = df_acum_robo_com_hora['Abertura'].dt.hour * 60 + df_acum_robo_com_hora['Abertura'].dt.minute
                 df_acum_robo_8_18 = df_robo_filtrado_8_18.sort_values('Abertura').copy()
                 if not df_acum_robo_8_18.empty: df_acum_robo_8_18['Resultado_Acumulado_8_18'] = df_acum_robo_8_18[target_result_col_name].cumsum(); ax_acr.plot(df_acum_robo_8_18['Abertura'], df_acum_robo_8_18['Resultado_Acumulado_8_18'], label='Acum. Ops 8h-18h (c/ Hora)', color='dimgray', linestyle=':', linewidth=1.5, alpha=0.9, zorder=4)
                 intervals_robo = { f'Melhor ({melhor_inicio_robo_hhmm}-{melhor_fim_robo_hhmm}, 8-18h)': (melhor_inicio_robo, melhor_fim_robo, 'green'), '9:15-12:30': (9*60+15, 12*60+30, 'cyan'), '9:00-12:30': (9*60, 12*60+30, 'red'), '10:00-12:30': (10*60, 12*60+30, 'magenta') }
                 for label, (start_min, end_min, color) in intervals_robo.items():
                     if start_min is not None and end_min is not None:
                         mask_intervalo = (df_acum_robo_com_hora['Minutos_Dia'] >= start_min) & (df_acum_robo_com_hora['Minutos_Dia'] <= end_min); df_intervalo = df_acum_robo_com_hora[mask_intervalo].copy()
                         if not df_intervalo.empty: df_intervalo['Resultado_Acumulado_Intervalo'] = df_intervalo[target_result_col_name].cumsum(); ax_acr.plot(df_intervalo['Abertura'], df_intervalo['Resultado_Acumulado_Intervalo'], label=f'Acum. {label}', color=color, linestyle='--', linewidth=1.2, alpha=0.8)
            else: print(f"    AVISO: Nenhuma operação COM HORA para plotar intervalos no gráfico acumulado de {robo}.")
            ax_acr.set_title(f'Resultado Acumulado - Robô {robo} ({periodo_robo_str})\nComparando Acumulado por Intervalo de Operação Diária (c/ Hora)'); ax_acr.set_xlabel('Data e Hora da Operação'); ax_acr.set_ylabel('Resultado Acumulado (pts)'); ax_acr.grid(True, linestyle='--', alpha=0.6); ax_acr.xaxis.set_major_formatter(mdates.DateFormatter('%d/%m/%y %Hh')); ax_acr.xaxis.set_major_locator(mticker.MaxNLocator(nbins=8)); plt.xticks(rotation=30, ha='right'); ax_acr.legend(loc='best', fontsize='small'); plt.tight_layout(); caminho_grafico_acum_robo = os.path.join(pasta_dados, f'acumulado_intervalos_{robo.replace(" ", "_")}.png'); plt.savefig(caminho_grafico_acum_robo); plt.close(fig_acr); print(f"    Gráfico Acumulado por Intervalo salvo.")
        else: print(f"    AVISO: Não foi possível gerar gráfico acumulado por intervalo para {robo}.")
        graficos_por_robo.append({ 'robo': robo, 'grafico_scatter': caminho_grafico_scatter, 'tabela': tabela_robo_data, 'grafico_linha': caminho_grafico_linha, 'limite': melhor_limite, 'grafico_acum_intervalo': caminho_grafico_acum_robo })
    for item in graficos:
        if item.get('tabela') and "{SOMA_MELHORES_PLACEHOLDER}" in item['tabela'][2][1]:
            item['tabela'][2][1] = f"{soma_melhores_ganhos_individuais_8_18:.2f}"
            print(f"Soma dos melhores ganhos individuais (8-18h) atualizada na tabela geral = {soma_melhores_ganhos_individuais_8_18:.2f}")
            break
    else:
        print("AVISO: Não foi possível encontrar/atualizar a tabela geral na lista 'graficos'.")
    pdf_path = os.path.join(pasta_dados, 'relatorio.pdf'); doc = SimpleDocTemplate(pdf_path, pagesize=A4, leftMargin=40, rightMargin=40, topMargin=40, bottomMargin=40); styles = getSampleStyleSheet(); style_title=ParagraphStyle(name='Titulo',parent=styles['h1'],alignment=TA_CENTER,spaceAfter=12); style_subtitle=ParagraphStyle(name='Subtitulo',parent=styles['h2'],spaceAfter=4,spaceBefore=10); style_normal=styles['Normal']; style_normal.alignment=TA_CENTER; style_message=ParagraphStyle(name='MensagemFinal',parent=styles['Normal'],spaceBefore=6,alignment=TA_LEFT); style_note=ParagraphStyle(name='NotaGrafico',parent=styles['Italic'],fontSize=8,spaceBefore=0,spaceAfter=6,alignment=TA_LEFT); style_table_header=ParagraphStyle(name='TableHeader',parent=styles['Normal'],fontName='Helvetica-Bold',alignment=TA_CENTER,fontSize=9); style_table_body=ParagraphStyle(name='TableBody',parent=styles['Normal'],alignment=TA_CENTER,fontSize=8); ts_base=[('ALIGN',(0,0),(-1,-1),'CENTER'),('VALIGN',(0,0),(-1,-1),'MIDDLE'),('FONTNAME',(0,0),(-1,0),'Helvetica-Bold'),('FONTNAME',(0,1),(-1,1),'Helvetica-Bold'),('FONTNAME',(0,2),(-1,-1),'Helvetica'),('TEXTCOLOR',(0,0),(-1,1),colors.whitesmoke),('TEXTCOLOR',(0,2),(-1,-1),colors.black),('BOTTOMPADDING',(0,0),(-1,1),8),('TOPPADDING',(0,0),(-1,1),8),('BOTTOMPADDING',(0,2),(-1,-1),4),('TOPPADDING',(0,2),(-1,-1),4),('BACKGROUND',(0,0),(-1,1),colors.darkgrey),('BACKGROUND',(0,2),(-1,-1),colors.lightgrey),('GRID',(0,1),(-1,-1),0.5,colors.black),('SPAN',(0,0),(-1,0)),]; ts_final=[('ALIGN',(0,0),(-1,-1),'CENTER'),('VALIGN',(0,0),(-1,-1),'MIDDLE'),('FONTNAME',(0,0),(-1,0),'Helvetica-Bold'),('TEXTCOLOR',(0,0),(-1,0),colors.whitesmoke),('BACKGROUND',(0,0),(-1,0),colors.darkgrey),('BOTTOMPADDING',(0,0),(-1,0),8),('TOPPADDING',(0,0),(-1,0),8),('FONTNAME',(0,1),(-1,-1),'Helvetica'),('TEXTCOLOR',(0,1),(-1,-1),colors.black),('BACKGROUND',(0,1),(-1,-1),colors.lightgrey),('BOTTOMPADDING',(0,1),(-1,-1),4),('TOPPADDING',(0,1),(-1,-1),4),('GRID',(0,0),(-1,-1),0.5,colors.black),]
    elements = []; elements.append(Paragraph(f"Relatórios de Resultados ({periodo_completo})", style_title)); elements.append(Paragraph(f"Total Operações Originais (c/ resultado): {count_operacoes_total_originais} | Válidas (c/ data): {len(banco_geral)} (Com Hora Definida: {count_operacoes_com_hora})", style_normal)); elements.append(Spacer(1, 12))
    for item in graficos:
        if item.get('grafico') and os.path.exists(item['grafico']):
            try: elements.append(Image(item['grafico'], width=500, height=250)); elements.append(Spacer(1, 6))
            except Exception as e: print(f"Erro img PDF: {e}")
        if item.get('tabela') is not None:
            try: header1 = [Paragraph(str(cell), style_table_header) for cell in item['tabela'][1]]; body_rows = [[Paragraph(str(cell), style_table_body) for cell in row_data] for row_data in item['tabela'][2:]]; table_data = [[Paragraph(item['tabela'][0][0], style_table_header)] + ['']*(len(header1)-1), header1] + body_rows; num_cols = len(header1); col_width = doc.width / num_cols; tabela = Table(table_data, colWidths=[col_width]*num_cols); tabela.setStyle(TableStyle(ts_base)); elements.append(tabela); elements.append(Spacer(1, 12))
            except Exception as e: print(f"Erro tab geral PDF: {e}")
    for item in graficos_por_robo:
        p_robo = Paragraph(f"<b>Robô: {item['robo']}</b>", style_subtitle); robo_title_table = Table([[p_robo]], colWidths=[doc.width], style=[('BACKGROUND', (0, 0), (-1, -1), colors.lightgrey), ('BOTTOMPADDING', (0,0), (-1,-1), 6), ('TOPPADDING', (0,0), (-1,-1), 6), ('LINEABOVE', (0,0), (-1,0), 1, colors.black), ('LINEBELOW', (0,-1), (-1,-1), 1, colors.black)]); elements.append(Spacer(1,12)); elements.append(robo_title_table); elements.append(Spacer(1, 6))
        if item.get('grafico_scatter') and os.path.exists(item['grafico_scatter']):
             try: elements.append(Image(item['grafico_scatter'], width=500, height=250)); elements.append(Paragraph("<i>Obs: Intervalo 'Melhor (8-18h)' calculado apenas c/ ops 8h-18h com hora. Pontos idem (tamanho proporcional).</i>", style_note)); elements.append(Spacer(1, 6))
             except Exception as e: print(f"Erro img scatter PDF: {e}")
        if item.get('tabela') is not None:
             try: header1 = [Paragraph(str(cell), style_table_header) for cell in item['tabela'][1]]; body_rows = [[Paragraph(str(cell), style_table_body) for cell in row_data] for row_data in item['tabela'][2:]]; table_data = [[Paragraph(item['tabela'][0][0], style_table_header)] + ['']*(len(header1)-1), header1] + body_rows; num_cols = len(header1); col_width = doc.width / num_cols; tabela = Table(table_data, colWidths=[col_width]*num_cols); tabela.setStyle(TableStyle(ts_base)); elements.append(tabela); elements.append(Spacer(1, 12))
             except Exception as e: print(f"Erro tab robo PDF: {e}")
        if item.get('grafico_linha') and os.path.exists(item['grafico_linha']):
            try: elements.append(Image(item['grafico_linha'], width=500, height=250)); elements.append(Spacer(1, 1)); elements.append(Paragraph(f"Limite Ideal Sugerido (80% picos+): {item['limite']} pts", style_message)); elements.append(Spacer(1, 12))
            except Exception as e: print(f"Erro img linha PDF: {e}")
        if item.get('grafico_acum_intervalo') and os.path.exists(item['grafico_acum_intervalo']):
            try: elements.append(Image(item['grafico_acum_intervalo'], width=500, height=280)); elements.append(Spacer(1, 12))
            except Exception as e: print(f"Erro img acum robo PDF: {e}")
    if not melhores_intervalos_todos_robos_df.empty:
        melhores_intervalos_todos_robos_df['Inicio_Horario'] = melhores_intervalos_todos_robos_df['Inicio_Intervalo'].apply(minutos_para_horario); melhores_intervalos_todos_robos_df['Fim_Horario'] = melhores_intervalos_todos_robos_df['Fim_Intervalo'].apply(minutos_para_horario)
        try: header_row = [Paragraph(h, style_table_header) for h in ['Robô', 'Início (Melhor 8-18h)', 'Fim (Melhor 8-18h)']]; body_rows = [[Paragraph(str(cell), style_table_body) for cell in [row['Robo'], row['Inicio_Horario'], row['Fim_Horario']]] for _, row in melhores_intervalos_todos_robos_df.iterrows()]; table_data = [header_row] + body_rows; tabela_final = Table(table_data, colWidths=[doc.width/3]*3); tabela_final.setStyle(TableStyle(ts_final)); elements.append(Paragraph("Melhores Intervalos por Robô (Baseado em Ops 8h-18h c/ Hora)", style_subtitle)); elements.append(tabela_final); elements.append(Spacer(1, 12))
        except Exception as e: print(f"Erro tab final PDF: {e}")
    mensagem_final_texto = ("<b>Atenção:</b> Esses dados são do passado, e como dizia minha avó, 'o passado é uma roupa que não nos cabe mais'. Eles não garantem o futuro, então use com sabedoria!")
    elements.append(Paragraph(mensagem_final_texto, style_message)); elements.append(Spacer(1, 24))
    try: print(f"Construindo PDF: {pdf_path}"); doc.build(elements); print(f"PDF construído.")
    except Exception as e: print(f"!!!!!!!! ERRO AO CONSTRUIR O PDF !!!!!!!!\n{traceback.format_exc()}"); raise e
    return pdf_path

# --- Rota Flask ---
@app.route('/', methods=['GET', 'POST'])
def index():
    try:
        if request.method == 'POST':
            upload_type = request.form.get('upload_type')
            print(f"\n--- Nova Requisição ---\nUpload Type: {upload_type}")
            
            if upload_type not in ['single', 'multiple']:
                return "Erro: Tipo de upload inválido. Escolha 'Arquivo Único (Excel)' ou 'Múltiplos Arquivos (CSV)'.", 400
            
            if upload_type == 'single':
                file_single = request.files.get('file_single')
                print(f"File Single provided: {file_single is not None}")
                files_multiple = []
                print(f"Files Multiple count: {len(files_multiple)}")
                
                if not file_single or not file_single.filename:
                    return "Erro: Nenhum arquivo Excel foi fornecido para o upload único.", 400
            else:
                files_multiple = request.files.getlist('files_multiple')
                print(f"Files Multiple count: {len(files_multiple)}")
                valid_files = [f for f in files_multiple if f and f.filename.lower().endswith('.csv')]
                print(f"Valid Multiple Files count: {len(valid_files)}")
                print(f"Valid Multiple Files names: {[f.filename for f in valid_files]}")
                file_single = None
                
                if not valid_files:
                    return "Erro: Nenhum arquivo CSV foi fornecido para o upload múltiplo.", 400
            
            pdf_path = processar_dados_e_gerar_pdf(upload_type, file_single, files_multiple, RELATORIOS_DIR_ABS)
            
            @after_this_request
            def remove_files(response):
                try:
                    shutil.rmtree(RELATORIOS_DIR_ABS)
                    print(f"Pasta {RELATORIOS_DIR_ABS} removida após requisição.")
                except Exception as e:
                    print(f"AVISO: Não foi possível remover pasta {RELATORIOS_DIR_ABS}: {e}")
                return response
            
            return send_file(pdf_path, as_attachment=True, download_name='relatorio.pdf')
        
        # Para GET: Renderizar o template HTML
        return render_template('index.html')
    
    except Exception as e:
        print(f"Erro na rota index: {e}")
        print(traceback.format_exc())
        return "Erro ao processar a requisição. Veja o log para detalhes.", 500
if __name__ == '__main__':
    app.run(debug=True, use_reloader=False)        